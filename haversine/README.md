# Modules

### processor
---
The haversine processor is the primary focus of the course's performance investigation.
This program parses JSON data generated by the haversine generator and calculates the average of all haversine distances between pairs of points.

##### Usage
```
[] = required, () = optional

cargo r --bin processor [json input file] (validation file)
```
- `JSON input file` - JSON containing pairs of points generated by the haversine generator.
- `validation file` - Binary file (.f64 extension) containing expected solution for each pair of points and the expected average of the sum of every pair. Useful for just making sure the calculations in the generator and the processor are aligned.

To run with granular profiling enabled:
```
[] = required, () = optional

cargo r --features profiling --bin processor [json input file] (validation file)
```
If any blocks or functions are profiled using the macros provided by the `libs/performance_metrics` library crate then granular performance statistics will be printed before the program exits.

### generator
---
The haversine generator is a simple tool used to generate the data consumed by the haversine processor.

##### Usage
```
[] = required, () = optional

cargo r --bin generator [num pairs to generate: int] [max clusters: int] [seed: int]
```
- `num pairs to generate` - Self explanatory. Since the point of this workspace is to investigate the performance of the haversine processor, this number should be reasonably high -- ideally around 1 million, though 250k to 500k also works if you don't want to wait long for the generator or processor. 10 million is the highest I would go, though you might be waiting quite a while.
- `max clusters` - Points are generated in clusters to try to somewhat avoid the effects of the [law of large numbers](https://en.wikipedia.org/wiki/Law_of_large_numbers). This argument provides an upper bound to the number of clusters that can be used (the number of clusters _actually_ used may be lower).
- `seed` - Seed for the random number generator.

The generator will write two files to the current working directory:
- `haversine_pairs.json`: JSON containing the generated haversine pairs.
- `haversine_answers.f64`: A binary file containing the expected solution for each pair of points and the expected average of the sum of every pair.

I recommend running the generator with `--release` or with any profile that has an `opt-level` of 2, 3, or "s".

### probe_page_fault_behavior
---
A simple program designed to probe Windows' page faulting behavior.

##### Usage
```
[] = required, () = optional

cargo r --bin probe_page_fault_behavior [page_count: int] (--write-direction) (--output-file)
```
- `--write-direction`:
    "forward"/"backward", defaults to "forward".
    Whether to write pages from front to back or back to front.

- `--output-file`:
    Name of file to dump CSV stats to.
    Useful for viewing data in a spreadsheet and creating charts.

Note: It's recommended to run this program with a large page_count (e.g. 1024 or more) then load the results up into a spreadsheet and create a chart from the data.

If an output filename is supplied, the program will loop from N = 0 to `page_count`, allocating N pages from `VirtualAlloc` each iteration.
It will then write 1 byte to each page and record a few statistics, primarily the number of "page faults" that Windows reports occurred (hint: it's not actually reporting the number of page faults).

If an output file is _not_ supplied, the program will do just 1 iteration with page_count pages `VirtualAlloc`'d to quickly dump some information to stdout. Regardless of whether the filename is supplied the program will always dump info to the terminal on the last iteration.

Info is printed whenever the page mapping pattern changes, e.g. touching the previous page caused 1 page to be mapped but touching the current page caused 16 pages to be mapped.
There are some special cases where a changing page mapping pattern does _not_ trigger a print.
See code for details.

Info printed includes the following:
- The number of pages mapped when touching the current page.
- A decomposition of the 64-bit pointer to the start of the current page into its page table indices and page offset (should be 0 since we only write to the first byte of each page).
- The number of pages mapped when touching the previous page.
- A decomposition of the 64-bit pointer to the start of the previous page into its page table indices and page offset.

### repetition_tests
---
Suites of performance-oriented tests where each test is run repeatedly until no faster time is recorded within some interval, upon which the next test in the suite is run.
Often suites will run ad infinitum until the process is manually terminated, though sometimes a suite will run just once and print some additional data.
Cycle counts and throughput in GB/s are recorded, though "throughput" is somewhat misleading in some of the tests because often it's more a measure of how fast it can get through a number of iterations of a loop rather than an actual measure of bytes processed.

See `README.md` in the `repetition_tests` directory for more information.

### libs
---
Supporting libraries used by other modules.

See `README.md` in the `libs` directory for more information.
